from slugify import slugify
import logging
import more_itertools
import re
import typing
from pathlib import Path
from typing import List

from jinja2 import Markup
from markdown2 import markdown

from ._type_hint_helpers import PathString

# some attributes will need to be protected from manipulation


def parse_content(content: str, matcher: str):
    """
    split content into attributes and content text

    Parameters:
        content : str
            The content to be parsed
        matcher : str, optional
            A compiled regular expression that splits the content.
            default `base_matcher`
    """

    matchmaker = re.compile(matcher, flags=re.M)
    parsed_content = re.split(matchmaker, content)
    content = parsed_content.pop().strip()

    attrs = list(filter(lambda x: x.strip(), parsed_content))
    return attrs, content


class Page:
    """
    Base component used to make web pages.

    All components that represent content in HTML, XML, or JSON generated by 
    Render Engine should be a Page object.

    Pages can be rendered directly from a template or from a file.

    Page objects can be used to extend existing page objects.


    Examples:
        ```
        # Basic Page with No Template Variables
        @site.register_route('basic_page.html')
        class BasicPage(Page):
            template = 'template_file.html' # user provided template

        # Basic Page with Variables
        @site.register_route('page_with_vars')
        class PageWithVars(Page):
            title = 'Site Title'

        # Page Loading from File
        @site.register_route('page_from_file')
        class PageFromFile(Page):
            content_path = 'index.md' # loaded from content path can be '.md' or '.html'

        # Page Inherited from Other Page
        @site.register_route('basic_page.html')
        class BasicPage(Page):
            template = 'template_file.html' # user provided template
            title = 'Base Page'

        @site.register_route('other_page.html')
        class InheritingPage(Page):
            # template will be inherited from the BasicPage
            title = 'Inherited Page'
        ```

    Attributes:
        engine: str, optional
            The engine that the Site should refer to or the site's default engine
        template: str
            The template that the Site should refer to. If empty, use site's default
        routes: List[str]
            all routes that the file should be created at. default []
        content_path: List[PathString], optional
            the filepath to load content from.
        slug: str
            The engine's default route filename
        content: str
            preprocessed text stripped from initialized content. This will not
            include any defined attrs
        html: str
            text converted to html from _content
    """

    engine: typing.Optional[str] = ""  # (default) inherits from Site
    template: typing.Optional[str] = ""  # (default) inherits from Site
    routes = [""]  # create page at each route
    list_attrs: typing.Optional[typing.Union[str]] = []  # comma-delim listed attrs
    no_index: bool = False  # hides from search index
    matcher: str = r"(^\w+: \b.+$)"  # expression to find attrs/vals
    content_path: typing.Optional[str] = ""
    content: typing.Optional[str] = ""
    title: typing.Optional[str] = ""
    slug: typing.Optional[str] = ""

    def __init__(self,):

        if self.content_path:
            content = Path(self.content_path).read_text()

            valid_attrs, self.content = parse_content(
                    content,
                    matcher=self.matcher,
                    )

            for attr in valid_attrs:
                name, value = attr.split(": ", maxsplit=1)

                # comma delimit attributes.
                if name.lower() in self.list_attrs:
                    value = [attrval.lower() for attrval in value.split(", ")]

                else:
                    value = value.strip()

                setattr(self, name.lower(), value)

        if not self.title:
            self.title = self.__class__.__name__

        if not self.slug:
            self.slug = self.title or self.__class__.__name__

        self.raw_content = self.content
        self.content = self.markup

        self.slug = slugify(self.slug)
        self.url = f"{self.routes[0]}/{self.slug}"


    @classmethod
    def from_content_path(cls, filepath):

        class NewPage(cls):
            content_path = filepath

        return NewPage()


    @property
    def html(self):
        """Text from self.content converted to html"""

        if self.content:
            return markdown(self.raw_content, extras=['fenced-code-blocks'])

        else:
            return ''

    @property
    def markup(self):
        """html = rendered html (not marked up). Is `None` if `content == None`"""
        if self.html:
            return Markup(self.html)

        else:
            return ''
